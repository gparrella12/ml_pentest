import os
import json
import numpy as np
import math
import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.lines import Line2D


def count_elements_below_threshold(vector, threshold):
    """
    Counts the number of elements in a vector that are below a given threshold.

    Parameters:
    - vector (list or array-like): The vector containing numerical elements to be compared against the threshold.
    - threshold (float or int): The value against which elements in the vector are compared.

    Returns:
    - int: The count of elements in the vector that are below the specified threshold.
    """
    count = 0
    for element in vector:
        if element < threshold:
            count += 1
    return count

def convert_size(size_bytes):
    """
    Convert a given file size in bytes to a string representation in B, KB, MB, etc.
    
    Parameters:
        size_bytes (int): The file size in bytes.
        
    Returns:
        str: A string representation of the file size.
    """
    if size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return "%s %s" % (s, size_name[i])


def plot_gamma_attack(base_path_standard, base_path_variant, save_path, query_values, lambda_values, file_name='inj_bytes_avg_classification.png', model_name='GBDT'):
    """
    Plot the detection rate for GAMMA Standard and GAMMA V2 based on injected bytes.
    
    Parameters:
        base_path_standard (str): The base path for the standard model results.
        base_path_variant (str): The base path for the variant model results.
        save_path (str): The path where the plot will be saved.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        file_name (str, optional): The name of the file where the plot will be saved. Defaults to 'inj_bytes_avg_classification.png'.
        model_name (str, optional): The name of the model. Defaults to 'GBDT'.
    """
    results_standard = []
    results_variant = []
    
    for lambda_value in lambda_values:
        for query_budget in query_values:
            result_file_standard = os.path.join(base_path_standard, f'results_{lambda_value}_{query_budget}.json')
            result_file_variant = os.path.join(base_path_variant, f'results_{lambda_value}_{query_budget}.json')
            
            with open(result_file_standard, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                for f in data.keys():
                    results_standard.append(data[f])
                    
            with open(result_file_variant, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                for f in data.keys():
                    if data[f]['injected_bytes'] < 0:
                        print(f)
                        continue
                    results_variant.append(data[f])
    
    min_injected_bytes = np.min([x['injected_bytes'] for x in results_standard] + [x['injected_bytes'] for x in results_variant])
    max_injected_bytes = np.max([x['injected_bytes'] for x in results_standard] + [x['injected_bytes'] for x in results_variant])
    step = (max_injected_bytes - min_injected_bytes) / 10
    x_axes = np.arange(min_injected_bytes, max_injected_bytes, step)
    
    y_axes_standard = []
    y_axes_variant = []
    for x in x_axes:
        y_standard = [result['final_classification'] for result in results_standard if result['injected_bytes'] <= x and result['injected_bytes'] >= x-step]
        y_variant = [result['final_classification'] for result in results_variant if result['injected_bytes'] <= x and result['injected_bytes'] >= x-step]
        
        y_axes_standard.append(np.mean(y_standard) if y_standard else np.nan)
        y_axes_variant.append(np.mean(y_variant) if y_variant else np.nan)
    
    if len(y_axes_standard) >= 2:
        y_axes_standard[0] = y_axes_standard[1]
    if len(y_axes_variant) >= 2:
        y_axes_variant[0] = y_axes_variant[1]
    
    plt.figure(figsize=(12, 8))
    plt.plot(x_axes, y_axes_standard, label='GAMMA Standard')
    plt.plot(x_axes, y_axes_variant, label='GAMMA V2')
    plt.xlabel('Injected bytes (KB)', fontsize=15, fontweight='bold')
    plt.ylabel(f'{model_name} detection rate', fontsize=15, fontweight='bold')
    plt.xticks(ticks=x_axes, labels=[convert_size(x) for x in x_axes], rotation=45, fontsize=14)
    plt.yticks(fontsize=14)
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=2, fontsize=16)
    plt.title('GAMMA ATTACK', fontsize=18)
    plt.grid(True, linestyle='--', linewidth=0.5, color='gray')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, file_name), dpi=300)
    plt.close()

def plot_detection_rate(base_path, save_path, query_values, lambda_values, file_name, model_name='GBDT'):
    """
    Plot the detection rate based on different budgets.
    
    Parameters:
        base_path (str): The base path for the results.
        save_path (str): The path where the plot will be saved.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        file_name (str): The name of the file where the plot will be saved.
        model_name (str, optional): The name of the model. Defaults to 'GBDT'.
    """
    points = {}
    max_x = -np.infty
    min_x = np.infty
    
    for query_budget in query_values:
        results_standard = []
        points[query_budget] = []
        for lambda_value in lambda_values:
            result_file_standard = os.path.join(base_path, f'results_{lambda_value}_{query_budget}.json')
            with open(result_file_standard, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                for f in data.keys():
                    if data[f]['injected_bytes'] < 0:
                        print(f)
                        continue
                    results_standard.append(data[f])
            points[query_budget].append((np.mean([x['final_classification'] for x in results_standard]), np.mean([x['injected_bytes'] for x in results_standard])))
    
    plt.figure(figsize=(12, 8))  

    for budget, points in points.items():
        x_values = [point[1] for point in points]
        max_x = max(max_x, np.max(x_values))
        min_x = min(min_x, np.min(x_values))
        y_values = [point[0] for point in points]
        plt.plot(x_values, y_values, marker='o', label=f'Budget {budget}')

    plt.axhline(y=0.5, color='black', linestyle='--', linewidth=1)
    plt.xlabel('Injected Bytes', fontsize=15, fontweight='bold') 
    plt.ylabel(f'{model_name} detection rate', fontsize=15, fontweight='bold')  
    plt.ylim([0, 1])
    plt.xlim([min_x - 10000, max_x + 10000])

    x_ticks = np.linspace(min_x - 10000, max_x + 10000, 10)
    x_labels = [convert_size(x) for x in x_ticks]
    plt.xticks(ticks=x_ticks, labels=x_labels, rotation=45, fontsize=14)  # Updated rotation and font size for X-axis ticks
    plt.yticks(fontsize=14)  # Updated font size for Y-axis ticks

    threshold_line = Line2D([0], [0], linestyle='--', linewidth=0.5, color='gray', label='Detection Threshold')

    # Retrieve existing handles and labels from the legend
    handles, labels = plt.gca().get_legend_handles_labels()

    # Add dummy line object to handles and labels
    handles.append(threshold_line)
    labels.append('Detection Threshold')

    # Create the legend with updated handles and labels
    plt.legend(handles=handles, labels=labels, loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=len(handles), fontsize=15) 

    plt.title('Detection Rate', fontsize=18)  # Updated font size for title
    plt.grid(True, linestyle='--', linewidth=0.5, color='gray')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, file_name), dpi=300)
    plt.close()

    
def plot_injected_bytes(base_path, save_path, query_values, lambda_values, title, name, model_name='GBDT', x_range_kb=None):
    """
    Plot the detection rate based on injected bytes.
    
    Parameters:
        base_path (str): The base path for the results.
        save_path (str): The path where the plot will be saved.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        title (str): The title of the plot.
        name (str): The name of the file where the plot will be saved.
        model_name (str, optional): The name of the model. Defaults to 'GBDT'.
        x_range_kb (tuple, optional): The range for the x-axis in KB. Defaults to None.
    """
    results_standard = {}
    max_injected_bytes = -np.infty
    min_injected_bytes = np.infty
    
    for query in query_values:
        results_standard[query] = []
        for l in lambda_values:
            result_file_standard = os.path.join(base_path, 'results_'+str(l)+'_'+str(query)+'.json')
            with open(result_file_standard, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                for f in data.keys():
                    if data[f]['injected_bytes'] < 0:
                        print(f)
                        continue
                    results_standard[query].append(data[f])
                    max_injected_bytes = np.max([max_injected_bytes, data[f]['injected_bytes']])
                    min_injected_bytes = np.min([min_injected_bytes, data[f]['injected_bytes']])
    
    if x_range_kb:
        min_injected_bytes = x_range_kb[0] * 1024  # Convert KB to Bytes
        max_injected_bytes = x_range_kb[1] * 1024  # Convert KB to Bytes
    
    step = (max_injected_bytes - min_injected_bytes) / 10
    x_axes = np.arange(min_injected_bytes, max_injected_bytes, step)
    
    y_to_plot = []
    for query in results_standard.keys():
        y_axes_standard = []
        for x in x_axes:
            y = []
            for result in results_standard[query]:
                if result['injected_bytes'] <= x and result['injected_bytes'] >= x-step:
                    y.append(result['final_classification'])
            if len(y) == 0:
                y_axes_standard.append(np.nan)  # Insert a NaN value when y is empty
            else:
                y_axes_standard.append(np.mean(y))
        
        if len(y_axes_standard) >= 2:
            y_axes_standard[0] = y_axes_standard[1]
        y_to_plot.append(y_axes_standard)
    
    plt.figure(figsize=(12, 8)) 
    for idx, query in enumerate(results_standard.keys()):
        plt.plot(x_axes, y_to_plot[idx], label=f'Queries {query}')

    plt.xlabel('Injected Bytes', fontsize=15, fontweight='bold') 
    plt.ylabel(f'{model_name} detection rate', fontsize=15, fontweight='bold') 

    # Updated rotation and font size for X-axis ticks
    plt.xticks(ticks=x_axes, labels=[convert_size(x) for x in x_axes], rotation=45, fontsize=14)  

    plt.yticks(fontsize=14)  # Updated font size for Y-axis ticks

    # Create the legend with updated column number and font size
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=len(results_standard.keys()), fontsize=16)  

    plt.title(title, fontsize=18)  # Updated font size for title
    plt.grid(True, linestyle='--', linewidth=0.5, color='gray')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, name), dpi=300)
    plt.close()


def plot_detection_rate_vs_query_budget(gamma_path, query_values, lambda_values, save_path, file_name='model_performance_vs_query_budget.png', y_range=None):
    """
    Plot the detection rate versus query budget for different models.
    
    Parameters:
        gamma_path (dict): A dictionary containing the paths for each model.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        save_path (str): The path where the plot will be saved.
        file_name (str, optional): The name of the file where the plot will be saved. Defaults to 'model_performance_vs_query_budget.png'.
        y_range (tuple, optional): A tuple containing the minimum and maximum y-values for the plot. Defaults to None.
    """
    y_to_plot = {}
    
    # Initialize y_to_plot
    for model in gamma_path.keys():
        y_to_plot[model] = []
    
    # Populate y_to_plot with mean predictions
    for model in gamma_path.keys():
        for query in query_values:
            all_predictions = []
            for lambda_ in lambda_values:
                path = os.path.join(gamma_path[model], 'results_{}_{}.json'.format(lambda_, query))
                predictions = []
                with open(path, 'r') as f:
                    data = json.load(f)
                    del data['attack_data']
                    for key in data.keys():
                        predictions.append(data[key]['final_classification'])
                all_predictions.extend(predictions)
            y_to_plot[model].append(np.mean(all_predictions))
    
    fig, ax = plt.subplots(figsize=(12, 8))
    for model, y_values in y_to_plot.items():
        ax.plot(query_values, y_values, marker='o', linewidth=2, markersize=8, label=model)
    ax.axhline(y=0.5, linestyle='--', color='black', label='Detection Threshold')
    ax.set_xticks(query_values)
    ax.get_xaxis().set_major_formatter(plt.ScalarFormatter())
    ax.set_title('Detection Rate vs Query Budget', fontsize=18)
    ax.set_xlabel('Query Budget', fontsize=15, fontweight='bold')
    ax.set_ylabel('Detection Rate', fontsize=15, fontweight='bold')
    ax.tick_params(axis='both', which='major', labelsize=14)
    if y_range is not None:
        plt.ylim(y_range)
    ax.grid(True, linestyle='--', linewidth=0.5, color='gray')
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=5, fontsize=16)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, file_name), dpi=300)
    plt.close()



def plot_avg_injected_bytes_vs_query_budget(gamma_path, query_values, lambda_values, save_path, file_name='avg_injected_bytes_vs_query_budget.png', lower_limit=None, upper_limit=None):
    """
    Plot the average injected bytes versus query budget for different models.
    
    Parameters:
        gamma_path (dict): A dictionary containing the paths for each model.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        save_path (str): The path where the plot will be saved.
        file_name (str, optional): The name of the file where the plot will be saved. Defaults to 'avg_injected_bytes_vs_query_budget.png'.
        lower_limit (tuple, optional): A tuple containing the minimum and maximum y-values for the lower part of the broken y-axis. Defaults to None.
        upper_limit (tuple, optional): A tuple containing the minimum and maximum y-values for the upper part of the broken y-axis. Defaults to None.
    """
    y_to_plot = {}
    
    # Initialize y_to_plot
    for model in gamma_path.keys():
        y_to_plot[model] = []
    
    # Populate y_to_plot with mean injected bytes
    for model in gamma_path.keys():
        for query in query_values:
            all_injected_bytes = []
            for lambda_ in lambda_values:
                path = os.path.join(gamma_path[model], f'results_{lambda_}_{query}.json')
                injected_bytes = []
                with open(path, 'r') as f:
                    data = json.load(f)
                    del data['attack_data']
                    for key in data.keys():
                        injected_bytes.append(data[key]['injected_bytes'])
                all_injected_bytes.extend(injected_bytes)
            y_to_plot[model].append(np.mean(all_injected_bytes) / 1024)  # Convert bytes to KB
    
    if lower_limit is not None and upper_limit is not None:
        fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(12, 8))
        ax1.set_ylim(upper_limit[0], upper_limit[1])
        ax2.set_ylim(lower_limit[0], lower_limit[1])
        ax1.spines['bottom'].set_visible(False)
        ax2.spines['top'].set_visible(False)
        ax1.xaxis.tick_top()
        ax1.tick_params(labeltop=False)
        ax2.xaxis.tick_bottom()

        for model, y_values in y_to_plot.items():
            ax1.plot(query_values, y_values, marker='o', linewidth=2, markersize=8, label=model)
            if ax2:
                ax2.plot(query_values, y_values, marker='o', linewidth=2, markersize=8)

        ax1.set_xticks(query_values)
        ax1.get_xaxis().set_major_formatter(plt.ScalarFormatter())
        #fig.suptitle('Average Injected Bytes vs Query Budget', fontsize=18)
        ax2.set_xlabel('Query Budget', fontsize=15, fontweight='bold')
        fig.text(0.04, 0.5, 'Average Injected Bytes (KB)', va='center', rotation='vertical', fontsize=15, fontweight='bold')

        ax1.tick_params(axis='both', which='major', labelsize=14)
        if ax2:
            ax2.tick_params(axis='both', which='major', labelsize=14)

        ax1.grid(True, linestyle='--', linewidth=0.5, color='gray')
        if ax2:
            ax2.grid(True, linestyle='--', linewidth=0.5, color='gray')

        ax1.legend(loc='upper center', bbox_to_anchor=(0.5, 1.3), ncol=4, fontsize=16)

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.subplots_adjust(left=0.11)  # Add space to the left for the central y-label
        plt.savefig(os.path.join(save_path, file_name))
        plt.close()
    else:
        fig, ax1 = plt.subplots(figsize=(12, 8))
        ax2 = None

        for model, y_values in y_to_plot.items():
            ax1.plot(query_values, y_values, marker='o', linewidth=2, markersize=8, label=model)

        ax1.set_xticks(query_values)
        ax1.get_xaxis().set_major_formatter(plt.ScalarFormatter())
        ax1.set_xlabel('Query Budget', fontsize=15, fontweight='bold')
        ax1.set_ylabel('Average Injected Bytes (KB)', fontsize=15, fontweight='bold')

        ax1.tick_params(axis='both', which='major', labelsize=14)

        ax1.grid(True, linestyle='--', linewidth=0.5, color='gray')

        ax1.legend(loc='upper center', bbox_to_anchor=(0.5, 1.2), ncol=4, fontsize=16)

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.savefig(os.path.join(save_path, file_name), dpi=300)
        plt.close()




def plot_heatmap(base_path, save_path, query_values, lambda_values, file_name='heatmap.png'):
    """
    Plot a heatmap to show how complexity metrics vary with different lambda and query budget values.
    
    Parameters:
        base_path (str): The base path for the results.
        save_path (str): The path where the plot will be saved.
        query_values (list): List of query budgets.
        lambda_values (list): List of lambda values.
        file_name (str, optional): The name of the file where the plot will be saved. Defaults to 'heatmap.png'.
    """
    # Initialize an empty numpy array to store elapsed_time values
    heatmap_data = np.zeros((len(lambda_values), len(query_values)))
    
    for i, lambda_value in enumerate(lambda_values):
        for j, query_budget in enumerate(query_values):
            result_file = os.path.join(base_path, f'results_{lambda_value}_{query_budget}.json')
            
            elapsed_times = []
            with open(result_file, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                for key in data.keys():
                    elapsed_times.append(data[key]['elapsed_time'])
            
            # Calculate the average elapsed_time for this lambda and query_budget combination
            heatmap_data[i, j] = np.mean(elapsed_times) if elapsed_times else np.nan
    
    fig, ax = plt.subplots()
    
    # Create the heatmap
    cax = ax.matshow(heatmap_data, cmap='coolwarm')
    
    # Label the axes
    ax.set_xticks(np.arange(len(query_values)))
    ax.set_yticks(np.arange(len(lambda_values)))
    ax.set_xticklabels(query_values)
    ax.set_yticklabels(lambda_values)
    
    # Axis labels
    plt.xlabel('Query Budget')
    plt.ylabel('Lambda')
    
    # Show a color bar
    fig.colorbar(cax)
    
    # Save the plot
    plt.savefig(os.path.join(save_path, file_name))
    plt.close()

def print_gamma_results(base_path, lambda_value, query_values, avg_detection_rate):
    """
    Prints the results of a given experiment.

    Parameters:
    - base_path (str): The base directory where the result files are located.
    - lambda_value (float): The lambda value used in the experiment.
    - query_budget (int): The query budget used in the experiment.
    - convert_size (function): A function to convert the size of injected bytes.
    - count_elements_below_threshold (function): A function to count elements below a given threshold in a list.
    - avg_detection_rate (float, optional): The average detection rate, default is 0.91.

    Returns:
    None
    """
    for query_budget in query_values:
        result_file = os.path.join(base_path, 'results_'+str(lambda_value)+'_'+str(query_budget)+'.json')
        with open(result_file, 'r') as file:
            data = json.load(file)
            attack_data = data['attack_data']
            del data['attack_data']
            elapsed_times = []
            queries = []
            stagnations = []
            final_classifications = []
            injected_bytes = []
            
            for f in data.keys():
                elapsed_times.append(data[f]['elapsed_time'])
                queries.append(data[f]['queries'])
                stagnations.append(1 if data[f]['stagnation'] else 0)
                final_classifications.append(data[f]['final_classification'])
                injected_bytes.append(data[f]['injected_bytes'])
    
    print("\n===Lambda: ", lambda_value,  "===")
    print("Mean Elapsed time: {:.4f} s, std. {:.4f}".format(np.mean(elapsed_times), np.std(elapsed_times)))
    print("Mean Queries: ", np.mean(queries), "std: ", np.std(queries))
    print("Sum of file that are stagnated: ", np.sum(stagnations))
    print("Mean of Final classification: ", np.mean(final_classifications), "std: ", np.std(final_classifications))
    print("File that evade classification: {}/{}".format(count_elements_below_threshold(final_classifications, 0.5), len(final_classifications)))
    print("Mean of injected bytes: ", convert_size(np.mean(injected_bytes)), "std: ", convert_size(np.std(injected_bytes)))
    print("\n${:.2f}\;({}{:.2f})$ & {:.2f}\% & {:.2f} $\pm$ {:.2f}\n".format(np.mean(final_classifications),'-' if np.mean(final_classifications) < avg_detection_rate else '+', np.abs(np.mean(final_classifications)- avg_detection_rate), count_elements_below_threshold(final_classifications, 0.5)*100/len(elapsed_times), np.mean(injected_bytes) / 1024, np.std(injected_bytes) / 1024))


def compute_mean_times(base_path, variant_path, query_values, lambda_values):
    """
    Computes and prints the mean elapsed times for the gamma attack and its variant V2.
    The results are formatted for inclusion in a LaTeX table.

    Parameters:
    - base_path (str): The base directory where the result files for the gamma attack are located.
    - variant_path (str): The base directory where the result files for the variant V2 are located.
    - query_values (list): A list of integers representing the query budgets to be considered.
    - lambda_values (list): A list of floats representing the lambda values to be considered.

    Returns:
    None
    """
    
    for query_budget in query_values:    
        for lambda_value in lambda_values:
            result_file = os.path.join(base_path, 'results_'+str(lambda_value)+'_'+str(query_budget)+'.json')
            result_file_variant = os.path.join(variant_path, 'results_'+str(lambda_value)+'_'+str(query_budget)+'.json')
            
            with open(result_file, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                elapsed_times = []
                queries = []
                for f in data.keys():
                    elapsed_times.append(data[f]['elapsed_time'])
                    queries.append(data[f]['queries'])
            
            with open(result_file_variant, 'r') as file:
                data = json.load(file)
                del data['attack_data']
                elapsed_times_variant = []
                queries_v2 = []
                for f in data.keys():
                    elapsed_times_variant.append(data[f]['elapsed_time'])
                    queries_v2.append(data[f]['queries'])
            
        print("\nQuery budget: ", query_budget, "===")
        print("Mean Elapsed time: {:.4f} s, std. {:.4f}".format(np.mean(elapsed_times), np.std(elapsed_times)))
        print("\n{} & {:.2f}  $\pm$ {:.2f} & {:.2f} & {:.2f}  $\pm$ {:.2f} & {:.2f}\n".format(query_budget, np.mean(elapsed_times), np.std(elapsed_times), np.mean(queries), np.mean(elapsed_times_variant), np.std(elapsed_times_variant), np.mean(queries_v2)))
