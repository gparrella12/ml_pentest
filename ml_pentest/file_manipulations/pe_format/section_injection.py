import copy
import random
import string
from ml_pentest.file_manipulations.pe_format.pe_manipulation import PEManipulation
import lief
import numpy as np


class SectionInjection(PEManipulation):
    """
    SectionInjection is a subclass of PEManipulation that performs section injection manipulation on a PE file.

    Attributes:
        _section_data (list): A list of byte arrays representing the section data to be injected into the PE file.
        _debug (bool): A flag indicating whether to print debug information during the manipulation.

    Methods:
        __init__(section_data: list, pe_file: np.array = None, debug: bool = False) -> None: 
            Constructor that initializes the SectionInjection object.
        apply_manipulation(manipulation_vector: list, section_names: list = None) -> list:
            Applies the section injection manipulation to the current PE file.
    """

    def __init__(self, section_data, pe_file=None, debug=False):
        """Initialize a section injection manipulation object.

        Args:
            section_data (list): a list of section data that will be injected into the PE file.
                                 Each element of the list is an array of bytes that represent the source
                                 section data.
            pe_file (np.array, optional): PE sample to manipulate, as numpy array. Defaults to None.
            debug (bool, optional): Where true, debug information are printed out during the manipulation. Defaults to False.
        """
        super().__init__(pe_file=pe_file)
        self._section_data = section_data
        self._debug = debug

    def apply_manipulation(self, manipulation_vector, section_names = None):
        """Apply the section injection manipulation to the current PE file.

        Args:
            manipulation_vector (list): a list of floats representing the manipulation vector. Each float in 
            the list is in the range [0, 1] and represents the percentage of the section data to be injected
            into the PE file.
            section_names (list, optional): a list of strings representing the names of the sections to be manipulated.
                                            If None, a random name of 8 characters is assigned to each section. Defaults to None.
        Returns:
            list: a list of bytes that represents the manipulated PE file.
        """
        if self._pe_file is None:
            raise ValueError('PE file not set!')
        lief_adv: lief.PE.Binary = lief.PE.parse(raw=self._pe_file.tolist())

        if lief_adv is None:
            raise ValueError('Error! PE file cannot be parsed')
        # Print the sections if debug mode is enabled.
        if self._debug:
            print('Sections')
            for s in lief_adv.sections:
                print(s.name, s.characteristics_lists)

        # Create a new section for each element in the manipulation vector.
        for i in range(len(manipulation_vector)):
            content = self._section_data[i]
            content_to_append = content[:int(round(len(content) * manipulation_vector[i]))]
            if section_names is not None:
                section_name = section_names[i]
            else:
                section_name = ''.join(random.choice(string.ascii_letters) for _ in range(8))
            s = lief.PE.Section(section_name)
            s.content = content_to_append
            lief_adv.add_section(s, lief.PE.SECTION_TYPES.UNKNOWN)

        # Use lief to rebuild the binary with the new sections.
        builder = lief.PE.Builder(lief_adv)
        builder.build()

        # Print the sections again if debug mode is enabled.
        if self._debug:
            exe_object = lief.PE.parse(builder.get_build())
            print('Sections - after')
            for s in exe_object.sections:
                print(s.name, s.characteristics_lists)

        # Return the manipulated binary as list of bytes.
        return builder.get_build()