import copy
import random
import string
from ml_pentest.file_manipulations.pe_format.pe_manipulation import PEManipulation
import lief
import numpy as np


class SectionInjection(PEManipulation):
    """
    SectionInjection is a subclass of PEManipulation that performs section injection manipulation on a PE file.
    This updated version of the class allows for more complex manipulations by taking into account the order of 
    section injection, section names, and section characteristics, unlike the traditional version.

    Attributes:
        _section_data (list): A list of byte arrays representing the section data to be injected into the PE file.
        _debug (bool): A flag indicating whether to print debug information during the manipulation.

    Methods:
        __init__(section_data: list, pe_file: np.array = None, debug: bool = False) -> None: 
            Constructor that initializes the SectionInjection object.
        apply_manipulation(manipulation_vector: list) -> list:
            Applies the section injection manipulation to the current PE file, considering the order of sections,
            their names, and characteristics.
    """

    def __init__(self, section_data, pe_file=None, debug=False):
        """Initialize a section injection manipulation object.

        Args:
            section_data (list): a list of section data that will be injected into the PE file.
                                 Each element of the list is an array of bytes that represent the source
                                 section data.
            pe_file (np.array, optional): PE sample to manipulate, as numpy array. Defaults to None.
            debug (bool, optional): Where true, debug information are printed out during the manipulation. Defaults to False.
        """ 
        super().__init__(pe_file=pe_file)
        self._section_data = section_data
        self._debug = debug

    def apply_manipulation(self, manipulation_vector):
        """Apply the section injection manipulation to the current PE file.

        Args:
            manipulation_vector (list): a list that represent a candidate into the genetic algorithm. The candidate
            is composed by a vector of real numbers in the range [0,1] that represent the percentage of the section, 
            the different names of section to inject, and the order of the section to inject and their characteristics.
        Returns:
            list: a list of bytes that represents the manipulated PE file.
        """
        if self._pe_file is None:
            raise ValueError('PE file not set!')
        lief_adv: lief.PE.Binary = lief.PE.parse(raw=self._pe_file.tolist())

        if lief_adv is None:
            raise ValueError('Error! PE file cannot be parsed')
        # Print the sections if debug mode is enabled.
        if self._debug:
            print('Sections')
            for s in lief_adv.sections:
                print(s.name, s.characteristics_lists)
        size = int(len(manipulation_vector) / 4)
        float_values = manipulation_vector[:size]
        section_names = manipulation_vector[size : 2*size]
        section_ordering = manipulation_vector[2*size : 3*size]
        section_characteristics = manipulation_vector[3*size : ]

        if self._debug:
            print('\nfloat_values:', float_values)
            print('section_names:', section_names)
            print('section_ordering:', section_ordering)
            print('section_characteristics:', section_characteristics , "\n")
        for _ in range(size):
            actual_min = min(section_ordering)
            index = section_ordering.index(actual_min)
            float_value = float_values[index]
            section_name = section_names[index]
            if self._debug:
                print(f'Inject sections nÂ° {index} with name {section_name} and float value {float_value} and characteristics {section_characteristics[index]}')
            s = lief.PE.Section(section_name)
            content = self._section_data[index]
            s.content = content[:int(round(len(content) * float_value))]
            lief_adv.add_section(s, section_characteristics[index])
            section_ordering[index] = np.infty

        # Use lief to rebuild the binary with the new sections.
        builder = lief.PE.Builder(lief_adv)
        builder.build()

        # Print the sections again if debug mode is enabled.
        if self._debug:
            exe_object = lief.PE.parse(builder.get_build())
            print('Sections - after')
            for s in exe_object.sections:
                print(s.name, s.characteristics_lists)

        # Return the manipulated binary as list of bytes.
        return builder.get_build()
