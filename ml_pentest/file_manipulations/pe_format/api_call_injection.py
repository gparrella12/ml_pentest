import copy
import random
import string
from ml_pentest.file_manipulations.pe_format.pe_manipulation import PEManipulation
import lief

# TO TEST
class ApiCallInjection(PEManipulation):
    """
    ApiCallInjection is a subclass of PEManipulation that performs API call injection manipulation on a PE file.

    Attributes:
        _api_calls (list): A list of tuples, each containing a DLL name and a function name to be injected into the PE file.
        _debug (bool): A flag indicating whether to print debug information during the manipulation.

    Methods:
        __init__(pe_file: str, api_calls: list, debug: bool = False) -> None: 
            Constructor that initializes the ApiCallInjection object.
        apply_manipulation(manipulation_vector: list[int]) -> list[int]:
            Applies the API call injection manipulation to the current PE file.
        _add_import(liefpe: lief.PE.Binary, dll: str, func_name: str) -> None:
            Adds an import to the PE file.
    """
    def __init__(self, pe_file, api_calls,debug=False):
        """
            Initializes an instance of the ApiCallInjection class.

            Args:
                pe_file (str): The path to the PE file to manipulate.
                api_calls (list): A list of couples [dll_name, function_name] to inject into the PE file.
                debug (bool, optional): Whether to output debug information. Defaults to False.
        """
        super().__init__(pe_file)
        self._api_calls = api_calls
        self._debug = debug
    

    def apply_manipulation(self, manipulation_vector):
        """
        Applies the API call injection manipulation to the PE file.

        Args:
            manipulation_vector (List[int]): A list of integers representing which API calls to inject. A value of 1 at index i indicates that the API call at index i should be injected.

        Returns:
            list: The manipulated PE file, as list of integers.
        """
        lief_adv: lief.PE.Binary = lief.PE.parse(raw=self._pe_file)
        if lief_adv is None:
            raise Exception("Failed to parse PE file")
        for i in range(len(manipulation_vector)):
            if manipulation_vector[i] == 1:
                dll_name, function_name = self._api_calls[i]
                self._add_import(lief_adv, dll_name, function_name)

        builder = lief.PE.Builder(lief_adv)
        builder.build_imports(True).patch_imports(True)
        builder.build()
        return builder.get_build()


    def _add_import(self, liefpe, dll, func_name):
        """
        Adds an import to the PE file.

        :param liefpe: The PE file to add the import to.
        :type liefpe: lief.PE.Binary
        :param dll: The name of the DLL to import.
        :type dll: str
        :param func_name: The name of the function to import.
        :type func_name: str
        """
        lib = [l for l in liefpe.imports if l.name.lower() == dll.lower()]
        lib = liefpe.add_library(dll) if lib == [] else lib[0]
        names = set([e.name for e in lib.entries])
        if not func_name in names:
            lib.add_entry(func_name)
