import time
import random
import numpy as np
from deap import base
from deap import creator
from deap import tools
import json
import string
import lief

from ml_pentest.file_manipulations.pe_format.section_injection_v2 import SectionInjection
from ml_pentest.attacks.blackbox.genetic_attack.genetic_engine.genetic_algorithm_base import GeneticEngine
from ml_pentest.attacks.blackbox.genetic_attack.GAMMA.gamma_attack import GammaAttack
from ml_pentest.attacks.blackbox.genetic_attack.GAMMA.gamma_result import GammaResult


class GammaSectionInjection(GammaAttack, GeneticEngine):
    """
        This class implements the GammaSectionInjection attack, which is a specialized form of genetic algorithm-based attack
        targeting machine learning models for malware classification. The class inherits functionalities from both the GammaAttack
        and GeneticEngine classes. This class implements the V2 attack developed in the thesis.

        Attributes:
            _section_population_length (int): The number of sections available for injection.
            _stagnation (int): The number of iterations without improvement before stopping the attack.
            _input_sample (np.ndarray): The input sample to be attacked.
            _section_population (list): A list of Section objects representing benign sections.
            _manipulator (SectionInjection): An object for applying manipulations to PE files.
            _sections_names (list): A list of section names.
            _sections_characteristics (list): A list of section characteristics.
            Other attributes inherited from GammaAttack and GeneticEngine.
    """


    def __init__(self, section_population, model_wrapper, population_size, lambda_value, iterations, input_sample=None, query_budget=None, seed=None, debug=False, hard_label=False, threshold=0.5, loss='l1', stagnation=5, use_popular_section_names = True):
        """
        Initializes the GammaSectionInjection object with the given parameters.

        Args:
            section_population (list): A list of Section objects representing the benign sections to use as candidates in the genetic algorithm.
            model_wrapper (ModelWrapper): The classifier to be attacked with classification function.
            population_size (int): The size of the population of individuals in the genetic algorithm.
            lambda_value (float): The lambda value used in the fitness function.
            iterations (int): number of maximum iterations of the genetic algorithm. If query_budget is used, the maximum number 
                              of iterations will be limited by the query budget.
            input_sample (np.ndarray): The input sample to be attacked. Default to None, if you want only to initialize the attack object.
            query_budget (int): The maximum number of queries allowed to the classifier. Defaults to None, which means 
                                that there is no limit to the number of queries.
            seed (int): The seed to be used in the random number generator.
            debug (bool): Whether to print debug information.
            hard_label (bool): Whether to use hard labels in the fitness function.
            threshold (float): The threshold used to detect a sample as a malware. Tipically, if the
                               confidence of the classifier is > 0.5, this is a malware, but you can 
                               change the value if this is not the case. This value is used only in hard label mode.
            loss (str): The loss function used in the fitness function to combine confidence and penalty term. With 
                        'l1' the loss is the absolute value of the difference in bytes between original samples and adversarial one. 
                        The other values are:
                        - 'cw', in which the loss is computed as max(confidence - self.threshold + 0.1, 0) + penalty.
                        - 'log', in which the loss is computed as -log(1 - confidence) + penalty.
            stagnation (int): the number of iteration without improvement before stopping the attack. Defaults to 5.
            use_popular_section_names (bool): Whether to use a list of popular section names or to generate random names. Defaults to True.
        Returns:
            None
        """
        super().__init__(model_wrapper, population_size,
                         lambda_value, iterations, query_budget, seed, debug, hard_label, threshold, loss)
        # Number of section to inject in the input sample
        self._section_population_length = len(section_population)
        # number of iterations without improvement before stopping
        self._stagnation = stagnation
        self._input_sample = input_sample
        self._section_population = section_population
        self._manipulator = SectionInjection(self._section_population, debug=False)
        if use_popular_section_names:
            self._sections_names = [
            '.text',
            '.data',
            '.rdata',
            '.bss',
            '.idata',
            '.edata',
            '.resource',
            '.reloc',
            '.debug',
            '.tls',
            # Altri nomi di sezioni comuni
            '.pdata',
            '.pdata',
            '.sxdata',
            '.xdata',
            '.pdata',
            '.edata',
            '.idata',
            '.rsrc',
            '.reloc',
            '.basedata',
            '.baserel',
            '.debug$F',
            '.debug$P',
            '.debug$S',
            '.debug$T',
            '.arch',
            '.config',
            '.CRT',
            '.drectve',
            '.edata',
            '.gfids',
            '.giats',
            '.gljmp',
            '.glue_7t',
            '.glue_7',
            '.idata',
            '.lit8',
            '.lit4',
            '.srdata',
            '.sxdata',
            '.textbss',
            '.text',
            '.tls',
            '.vmp0',
            '.vmp1',
            '.vmp2',
            '.vmp3',
            '.vmp4',
            '.vmp5',
            '.vmp6',
            '.vmp7',
            '.vmp8',
            '.vmp9',
            '.vmpA',
            '.vmpB',
            '.vmpC',
            '.vmpD',
            '.vmpE',
            '.vmpF'
        ]
        else:
            self._sections_names = []
            for _ in range(10*self._section_population_length):
                 self._sections_names.append(''.join(random.choice(string.ascii_letters) for _ in range(8)))
        self._sections_characteristics =  [
                    lief.PE.SECTION_TYPES.BSS,
                    lief.PE.SECTION_TYPES.DATA,
                    lief.PE.SECTION_TYPES.EXPORT,
                    lief.PE.SECTION_TYPES.TEXT,
                    lief.PE.SECTION_TYPES.UNKNOWN
                ]

    def initialization(self):
        """
        Initializes the genetic algorithm by creating the necessary objects and registering the required functions
        with the DEAP toolbox. It also creates a population of individuals and evaluates their fitness.

        Returns:
            None
        """
        if self._input_sample is None:
            raise ValueError("Input sample is not provided! Use the method set_sample to set it before running attack.")
        self._start_time = time.time()
        if self._debug:
            print("==== Initialization phase ====")
        ################################### INITIALIZE DHE DEAP TOOLBOX ###################################
        # creates a Fitness object that minimizes fitness. The weights argument is used to define the sign of the fitness.
        creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
        # creates an Individual class that is a list of floats with the fitness attribute set to the FitnessMin class
        #  The "Individual" class represents a potential solution to the problem being solved (a candidate solution)
        creator.create("Individual", list , fitness=creator.FitnessMin)
        # Create a toolbox for evolution that contains the evolutionary operators
        toolbox = base.Toolbox()

        def create_individual():
            """
            Generates a random individual with mixed characteristics.

            This function creates a random individual by combining various attributes, including random floats, modified section names,
            integer indices, and random section characteristics. The modified section names are formed by adding two random letters
            to each original section name. The length of the generated individual is determined by the `_section_population_length`
            attribute of the calling object.

            Returns:
                list: A list containing randomly generated attributes, including:
                    - Random float values (length: `_section_population_length`)
                    - Modified section names (length: `_section_population_length`)
                    - Integer indices (length: `_section_population_length`)
                    - Random section characteristics (length: `_section_population_length`)

            Note:
                This function requires the `random` module and the `string` module from the Python standard library.
            """
            integer_list = list(range(self._section_population_length))
            random.shuffle(integer_list)
            original_names = random.sample(self._sections_names, self._section_population_length)
            for i in range(len(original_names)):
                original_names[i] = original_names[i] + "".join(random.choices(string.ascii_letters, k=2))
            return [random.random() for _ in range(self._section_population_length)] + [name for name in original_names] + [i for i in integer_list] + [random.choice(self._sections_characteristics) for _ in range(self._section_population_length)]
        # Register the function that create the indivuals in the toolbox
        toolbox.register(alias='attributes', function=create_individual)
        toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.attributes)
        # Create a population of individuals and registering it in the toolbox for use in the genetic algorithm.
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        # Register customized crossover and mutation operators
        toolbox.register("crossover", self._my_crossover)
        # Mutate function mutates an individual with a probability of 0.3 using the random_mutation method.
        toolbox.register("mutate", self._random_mutation, indpb=0.3)
        # Selects the best individuals from a population using the selTournament method
        toolbox.register("select", tools.selTournament, tournsize=self._population_size)
        # saves the toolbox object into the class attribute
        self._toolbox = toolbox

        # The _slice_indexes list is used to slice the population into smaller subpopulations.
        # The single element in the list represents the end index of the first subpopulation,
        # which is equal to the total population size.
        self._slice_indexes = [self._population_size]
        ###############################################################################
        # Creates a population of individuals and evaluates their fitness on the input sample.
        self._population = self._toolbox.population(n=self._population_size)

        # initialize this tuple that contain the best fit and the best candidate actually discovered
        self._best_candidate = (np.infty, None)
        self._evaluate(self._population)
        # CXPB  is the probability with which two individuals are crossed
        self._CXPB = 0.9
        # MUTPB is the probability for mutating an individual
        self._MUTPB = 0.3
        # this is the index of the current iteration
        self._iteration = 0

        # The _last_n_best_fits list is used to keep track of the best fitness values of the last n iterations,
        # where n is the stagnation parameter passed to the constructor of the GammaSectionInjection class.
        # This list is used to check if the algorithm has stagnated, i.e., if the best fitness value has not
        # improved for n iterations.
        self._last_n_best_fits = []

    def termination_condition(self):
        """
        Check if the termination condition has been met.

        Returns:
            bool: True if the termination condition has been met, False otherwise.
        """
        if len(self._last_n_best_fits) == self._stagnation and (all(
                np.array(self._last_n_best_fits) == np.infty) or
                all((np.array(self._last_n_best_fits) - self._best_fitness) < 1e-6)):
            if self._debug:
                print('Stagnating result!')
            return True
        if not self._query_budget:
            if self._debug and self._iteration >= self._iterations:
                print("\nTerminating condition met! g:{}, iterations:{}".format(
                    self._iteration, self._iterations))
            return self._iteration >= self._iterations
        if self._debug and ((self._iteration >= self._iterations) or ((self._iteration+1)*self._population_size >= self._query_budget)):
            print("\nTerminating condition met! g:{}, iterations:{}, query budget {}".format(
                self._iteration, self._iterations, self._query_budget))
        return (self._iteration >= self._iterations) or ((self._iteration+1)*self._population_size >= self._query_budget)

    def iteration(self):
        """
        Perform one iteration of the genetic algorithm.

        Returns:
            None
        """
        if self._debug:
            print("\n==== Iteration {} ====".format(self._iteration + 1))
        ############## SELECTION ################
        # Select the next generation individuals
        selected_individuals = self._toolbox.select(
            self._population, self._population_size)
        # Clone the selected individuals
        selected_individuals = list(
            map(self._toolbox.clone, selected_individuals))
        ############## CROSSOVER ################
        # Apply crossover and mutation on the selected individuals
        for child1, child2 in zip(selected_individuals[::2], selected_individuals[1::2]):
            if random.random() < self._CXPB:
                self._toolbox.crossover(child1, child2)
                del child1.fitness.values
                del child2.fitness.values
        ############## MUTATION ################
        for mutant in selected_individuals:
            if random.random() < self._MUTPB:
                self._toolbox.mutate(mutant)
                del mutant.fitness.values

        # Evaluate the individuals with an invalid fitness
        # (i.e. the ones that have been mutated or crossed in the previous step)
        to_evaluate = [ind for ind in selected_individuals if not ind.fitness.valid]
        # This line of code appends the length of the to_evaluate list to the _slice_indexes list.
        # This is required because _slice_indexes is used to keep track of the indexes of the individuals
        # in the population that belong to each section.
        # By appending the length of to_evaluate, we are essentially marking the end of the current section and
        # the beginning of the next section in the population. This is important for the selection process,
        # as it ensures that individuals from each section are selected with equal probability.
        self._slice_indexes.append(len(to_evaluate))

        self._evaluate(to_evaluate)

        self._population.extend(to_evaluate)
        # Compute values to determine stagnation condition
        fits = [candidate.fitness.values[0] for candidate in self._population]
        self._best_fitness = min(fits)
        self._last_n_best_fits.insert(0, self._best_fitness)
        self._last_n_best_fits = self._last_n_best_fits[:self._stagnation]

        if self._debug:
            print(f'>{self._iteration} - Global min: {self._best_fitness}')
        self._iteration += 1

    def _evaluate(self, to_evaluate):
        """
        Evaluates the fitness of each individual in the population by computing the fitness function for each individual.

        Parameters
        ----------
        to_evaluate : list
            A list of individuals to evaluate.

        Returns
        -------
        None
        """
        if not self._model_wrapper._use_batch:
            fitness = []
            for candidate in to_evaluate:
                fit_value, adv_sample = self.compute_fitness_function(self._input_sample, candidate)
                fitness.append([fit_value])
                if fit_value < self._best_candidate[0]:
                    self._best_candidate = (fit_value, adv_sample)
        else:
            raise NotImplementedError("Batch mode not implemented yet")

        if self._debug:
            print("Fitness values: {}".format(fitness))
        for candidate, fit in zip(to_evaluate, fitness):
            candidate.fitness.values = fit

    def exiting_operations(self):
        """
        Performs the exiting operations of the genetic algorithm, including selecting the best candidate, applying the
        manipulation to the input sample, and returning a GammaResult object with the manipulated sample and other
        relevant information.

        Returns
        -------
        GammaResult
            A GammaResult object containing the manipulated sample and other relevant information.
        """
        del creator.FitnessMin
        del creator.Individual
        adv_sample = self._best_candidate[1]
        if self._debug:
            print("Best fit: ", self._best_candidate[0])
            if adv_sample is not None:
                print("Confidence: ", self.compute_confidence(bytes(adv_sample)))
        return GammaResult(adv_sample, time.time() - self._start_time, self._iteration, (self._iteration+1) * self._population_size, len(self._last_n_best_fits) == self._stagnation and (
            all(np.array(self._last_n_best_fits) == np.infty) or all((np.array(self._last_n_best_fits) - self._best_fitness) < 1e-6)))

    def compute_fitness_function(self, sample, manipulation_vector):
        """
        Compute the fitness function for evaluating the quality of an adversarial sample generated through manipulation.

        Args:
            sample (np.array): The original sample (PE file) for manipulation.
            manipulation_vector (array-like): A vector containing manipulation instructions.

        Returns:
            tuple: A tuple containing two values:
                - The computed fitness value, which consists of a loss term and a regularization term.
                - The adversarial sample generated after applying manipulation.

        Note:
            The fitness function evaluates the quality of an adversarial sample by considering its loss and regularization terms.
            The loss term measures the discrepancy between the confidence of the manipulated sample and the reference confidence.
            The regularization term takes into account the impact of the manipulation vector on the population of specific sections within the PE file.
        """
        self._manipulator.set_pe_file(sample)
        adv_sample = self._manipulator.apply_manipulation(manipulation_vector)
        return self._compute_loss(self.compute_confidence(bytes(adv_sample)), self.compute_reg_term(manipulation_vector, self._section_population)), adv_sample

    def _compute_loss(self, confidence, penalty):
        """
        Compute the loss value based on the given confidence and penalty terms.

        Args:
            confidence (float): The confidence score of the manipulated sample.
            penalty (float): The penalty term associated with the manipulation.

        Raises:
            ValueError: If the selected loss function is not recognized.

        Returns:
            float: The computed loss value.

        Note:
            The loss value is calculated using different methods depending on the chosen loss function.
            - For 'l1' loss, the loss is the sum of confidence and penalty.
            - For 'cw' (Carlini-Wagner) loss, the loss is the maximum of (confidence - threshold + 0.1) and 0, plus penalty.
            - For 'log' loss, the loss is -log(1 - confidence) plus penalty.
        """
        if self._debug:
            print("Confidence: ", confidence, "Penalty: ", penalty)
        if self._loss == 'l1':
            return confidence + penalty
        if self._loss == 'cw':
            return max(confidence - self._threshold + 0.1, 0) + penalty
        if self._loss == 'log':
            return -np.log(1 - confidence) + penalty
        raise ValueError('NO LOSS')

    def compute_reg_term(self, manipulation_vector, section_population):
        """
        Compute the regularization term for the given manipulation vector based on the section population.

        Args:
            manipulation_vector (array-like): A vector containing manipulation instructions.
            section_population (list): A list of section population for each corresponding manipulation instruction.

        Returns:
            float: The computed regularization term.

        Note:
            The regularization term quantifies the impact of the manipulation vector on the population of specific sections within the PE file.
            It is calculated by summing the product of each manipulation instruction's weight in the vector and the corresponding section's population size.
            The overall regularization term is scaled by the lambda parameter.
        """
        injected_bytes = 0
        for i in range(int(len(manipulation_vector)/4)):
            injected_bytes += manipulation_vector[i] * \
                len(section_population[i])
        return self._lambda * injected_bytes

    def compute_confidence(self, sample):
        """
        Compute the confidence score for the given sample using the model wrapper.

        Args:
            sample (bytes): The sample (PE file) for which to compute the confidence score.

        Returns:
            float: The computed confidence score.

        Note:
            This function calculates the confidence score by classifying the input sample using the model wrapper.
            If the hard label option is enabled, the function returns positive infinity if the confidence score is above the threshold, otherwise 0.
            Otherwise, it returns the actual confidence score obtained from the model wrapper.
        """
        confidence = self._model_wrapper.classify_sample(sample)
        if self._hard_label:
            return np.infty if confidence > self._threshold else 0
        return confidence

    def run(self):
        """
        Runs the genetic algorithm by performing initialization, iterations, and exiting operations until the termination
        condition is met. Returns the result of the exiting operations and sets the elapsed time attribute.

        :return: The result of the exiting operations and the elapsed time.
        """
        self.initialization()
        while not self.termination_condition():
            self.iteration()
        result = self.exiting_operations()
        return result

    def get_attack_characteristic(self):
        """
        Retrieve the characteristics of the attack in a structured JSON format.

        Returns:
            str: A JSON-encoded string containing the attack characteristics.

        """
        attack_characteristics = {
            "attack": self.__class__.__name__,
            "population_size": self._population_size,
            "lambda": self._lambda,
            "max_iterations": self._iterations,
            "query_budget": self._query_budget,
            "seed": self._seed,
            "hard_label": self._hard_label,
            "threshold": self._threshold,
            "loss": self._loss,
            "stagnation": self._stagnation,
            "section_population_length": self._section_population_length
        }
        return json.dumps(attack_characteristics)


    def _random_mutation(self ,individual, indpb):
        """
        Apply random mutation to an individual based on the given mutation probability.

        Args:
            individual (list): The individual's manipulation vector.
            indpb (float): The probability of mutation for each element in the individual.

        Returns:
            list: The mutated individual.

        Note:
            This function performs a random mutation on the individual's manipulation vector, which is divided into four sections:
            1. Float values section: The first quarter of the vector.
            2. Section names section: The second quarter of the vector.
            3. Section order section: The third quarter of the vector.
            4. Section characteristics section: The fourth quarter of the vector.

            The mutation operation is performed as follows:
            - Float values section: A random value between -0.25 and 0.25 is added to each element with a probability determined by indpb. Values exceeding the range [0, 1] are constrained within that range.
            - Section names section: With a probability determined by indpb, the entire section name is replaced with a new random name consisting of 8 ASCII letters.
            - Section order section: The order of sections can be shuffled with a probability determined by indpb.
            - Section characteristics section: With a probability determined by indpb, the characteristic of a section is replaced by a randomly chosen characteristic from a predefined list of section characteristics.
        """
        k = int(len(individual) / 4)
        # random mutation for float values
        for i in range(k):
            if random.random() < indpb:
                mutation = random.uniform(-0.25, 0.25)
                individual[i] = max(0, min(1, individual[i] + mutation))
        # random mutation for section names
        for i in range(k, 2*k):
            if random.random() < indpb:
                new_name = "".join(random.choices(string.ascii_letters, k=8))
                individual[i] = new_name
        # shuffle the section order
        if random.random() < indpb:
            individual[2*k:3*k] = random.sample(range(k), len(individual[2*k:3*k]))
        # change the section characteristics
        for i in range(3*k, 4*k):
            if random.random() < indpb:
                individual[i] = random.choice(self._sections_characteristics)
        return individual

    def _my_crossover(self, child1, child2):
        """
        Perform a customized crossover operation on two children to generate new offspring.

        Args:
            child1 (list): The first child's manipulation vector.
            child2 (list): The second child's manipulation vector.

        Returns:
            tuple: A tuple containing two lists, representing the generated offspring (child1 and child2).

        Note:
            This function applies a customized crossover operation to two children's manipulation vectors to generate new offspring. The manipulation vector is divided into four sections:
            1. Float values section: The first quarter of the vector.
            2. Section names section: The second quarter of the vector.
            3. Section positions section: The third quarter of the vector.
            4. Section characteristic section: The fourth quarter of the vector.

            The crossover operation is performed as follows:
            - Section positions section: Elements that are not in the same positions in both candidates are swapped.
            - Float values section: A one-point crossover is performed at a randomly chosen crossover point. The crossover point is ensured to be non-zero.
            - Section names section: A one-point crossover is performed at another randomly chosen crossover point. The crossover point is ensured to be different from the size of the section.
            - Section characteristic section: Elements that are not in the same positions in both candidates are swapped.
        """
        size = int(len(child1) / 4)
        
        # Swap elements for the section positions section
        for i in range(size * 2, size * 3):
            if child1[i] != child2[i]:
                child1[i], child2[i] = child2[i], child1[i]
        
        # One-point crossover for float values section
        cxpoint_float = random.randint(0, size - 1)
        while cxpoint_float == 0:
            cxpoint_float = random.randint(0, size - 1)
        child1[cxpoint_float:size], child2[cxpoint_float:size] = child2[cxpoint_float:size], child1[cxpoint_float:size]

        
        # One-point crossover for section names section
        cxpoint_names = random.randint(size, 2 * size - 1)
        while cxpoint_names == size - 1:
            cxpoint_names = random.randint(size, 2 * size - 1)
        child1[cxpoint_names:2 * size], child2[cxpoint_names:2 * size] = child2[cxpoint_names:2 * size], child1[cxpoint_names:2 * size]

        
        # Swap elements for the section characteristic section
        for i in range(size * 3, size * 4):
            if child1[i] != child2[i]:
                child1[i], child2[i] = child2[i], child1[i]
        
        return child1, child2