import os
import pickle
import lief
import magic
from tqdm import tqdm
import sys
import numpy as np
import json
from ml_pentest.attacks.blackbox.genetic_attack.GAMMA.gamma_attack import GammaAttack
from ml_pentest.models.wrappers.model_wrapper import ModelWrapper
import random


# From https://github.com/pralab/secml_malware/blob/master/secml_malware/attack/blackbox/c_gamma_evasion.py
def create_section_population_from_list(folder, what_from_who):
    """
    Create the section population from files contained in a specified folder
    Parameters
    ----------
    folder : str
            the folder containing the file to open
    what_from_who : list
            a list of file (section name, file names) that specifies what extract from who
    Returns
    -------
    list
            the section population list
    """
    section_population = []
    for entry in what_from_who:
        what, who = entry
        path = os.path.join(folder, who)
        lief_pe_file = lief.PE.parse(path)
        for s in lief_pe_file.sections:
            if s.name == what:
                section_population.append(s.content)
    return section_population


def create_section_population_from_folder(folder, how_many, sections_to_extract=None,
                                          cache_file=None,
                                          size_lower_bound=None):
    """
    Extract sections from a given folder

    Parameters
    ----------
    folder : str
            the folder containing programs used for extracting sections
    how_many : int
            how many sections to extract in general
    sections_to_extract : list, optional, default None
            the list of section names to use. If None, it will extract only .data sections
    cache_file : str, optional, default None
            if set, it stores which section from what program has been used inside a pickled object, stored in path
    size_lower_bound : int, optional, default None
            if set, it will discard all the sections whose content length is less that such parameter

    Returns
    -------
    list, list
            the section population and what has been extracted from who
    """
        
    if sections_to_extract is None:
        sections_to_extract = [".data"]
    section_population = []
    counter = 0
    what_from_who = []
    if cache_file and os.path.isfile(cache_file):
        with open(cache_file, 'rb') as section_file:
            file_to_consider = pickle.load(section_file)
            file_to_consider = [f[1] for f in file_to_consider]
    else:
        file_to_consider = os.listdir(folder)
    for filename in file_to_consider:
        path = os.path.join(folder, filename)
        if "PE" not in magic.from_file(path):
            continue
        lief_pe_file = lief.PE.parse(path)
        if lief_pe_file is None:
            print("ERROR parsing {}".format(path), file=sys.stderr)
            continue
        for s in lief_pe_file.sections:
            if s.name in sections_to_extract:
                if size_lower_bound and len(s.content) < size_lower_bound:
                    continue
                if len(s.content) == 0:
                    continue
                section_population.append(s.content)
                what_from_who.append((s.name, filename))
                counter += 1
        if counter >= how_many:
            break
    section_population = section_population[:how_many]
    if cache_file and not os.path.isfile(cache_file):
        with open(cache_file, 'wb') as section_file:
            pickle.dump(what_from_who, section_file)
    return section_population, what_from_who


def generate_adv_samples_from_folder(source_folder, destination_folder, gamma_attack, model ,result_file=None, debug = False, build_all = False, check_existing_file = False):
    """Generate an advresarial sample for each PE file in the source folder and save it in the destination folder with the same name.

    Args:
        source_folder (str): the path of the folder with the PE files to attack
        destination_folder (str): the path of the folder where to save the adversarial samples
        gamma_attack (GammaAttack): an object of one subclasses of GammaAttack. It must be already initialized with the target model and all required parameters.
        model (ModelWrapper): the model to attack.
        result_file (str): the path of the file where to save the results of the attack. The results are saved in JSON, 
                           the file can be loaded as Python dictionary with the filename as key and the results of the attack as value. Default is None.
        debug (boolean): if True, print some debug information. If the file already exists, it will be overridden. Default is False.
        build_all (boolean): a boolean that is true if you want to build all the sections of the PE file, false otherwise. Default is false.
        check_existing_file (boolean): a boolean that is true if you want to check if the file already exists in the destination folder, false otherwise. Default is false.
    Returns:
        float: the mean absolute difference in bytes between the original samples and the adversarial samples.
    Raises:
        TypeError: if the gamma_attack parameter is not an object of one subclasses of GammaAttack.
    """
    if type(gamma_attack) == GammaAttack:
        raise TypeError("It is required an object of one subclasses of GammaAttack!")
    if not os.path.isdir(source_folder) or not os.path.isdir(destination_folder):
        raise ValueError("source_folder and destination_folder must be valid paths to folders!")
    if model is None:# or not isinstance(model, ModelWrapper):
        raise ValueError("Model must be a valid ModelWrapper object!")
    if result_file is not None:
        data_to_save = {}
    files = os.listdir(source_folder)
    for i in tqdm(range(len(files))):   
        try:
            f = files[i]
            if check_existing_file and os.path.exists(os.path.join(destination_folder, f)):
                continue
            path = os.path.join(source_folder, f)
            if debug:
                print(f"Processing {path}...")
            if "PE" not in magic.from_file(path):
                print(f"Note that {path} is not a PE file! Skipping...", file=sys.stderr)
                continue
            with open(path, "rb") as file_handle:
                sample = file_handle.read()
            # Set the input sample
            gamma_attack.set_sample(sample)
            # Run the attack
            result = gamma_attack.run()
            # Get the adversarial sample
            adv_sample = result.get_adv_sample()

            # Save the adversarial sample
            exe_object = lief.PE.parse(adv_sample)
            builder = lief.PE.Builder(exe_object)
            builder.build()
            if build_all:
                builder.build_dos_stub(enable = True)
                builder.build_imports(enable = True)
                builder.build_overlay(enable = True)
                builder.build_relocations(enable = True)
                builder.build_resources(enable = True)
                builder.build_tls(enable = True)
            builder.write(os.path.join(destination_folder, f))

            if result_file is not None:
                    data_to_save[f] = {}
                    data_to_save[f]['elapsed_time']= result.get_elapsed_time()
                    data_to_save[f]['iterations']= result.get_iterations()
                    data_to_save[f]['queries']= result.get_queries()
                    data_to_save[f]['stagnation']= result.get_stagnation()
                    data_to_save[f]['final_classification'] = model.classify_sample(bytes(adv_sample))
                    data_to_save[f]['injected_bytes'] = os.path.getsize(os.path.join(destination_folder, f)) - os.path.getsize(os.path.join(source_folder, f))

                    if data_to_save[f]['injected_bytes'] < 0:
                        print("\nWARNING: injected bytes < 0 for {} :\t Original Size {} \t Adv Size: {}\n".format(f, os.path.getsize(os.path.join(source_folder, f)), os.path.getsize(os.path.join(destination_folder, f))))
        except Exception as e:
            print("Error while processing file {}: {}".format(f, e), file=sys.stderr)
            continue 
    if result_file is not None:
        data_to_save['attack_data'] = json.loads(gamma_attack.get_attack_characteristic())
        with open(result_file, 'w') as outfile:
            json.dump(data_to_save, outfile)
    
    return

def generate_adv_samples_from_file(source_file, destination_folder, gamma_attack, model ,result_file=None, debug = False, build_all = False):
    """Generate an advresarial sample for each PE file in the source folder and save it in the destination folder with the same name.

    Args:
        source_file (str): the path of the pickled file with the PE files to attack, as list of paths.
        destination_folder (str): the path of the folder where to save the adversarial samples
        gamma_attack (GammaAttack): an object of one subclasses of GammaAttack. It must be already initialized with the target model and all required parameters.
        model (ModelWrapper): the model to attack.
        result_file (str): the path of the file where to save the results of the attack. The results are saved in JSON, 
                           the file can be loaded as Python dictionary with the filename as key and the results of the attack as value. Default is None.
        debug (boolean): if True, print some debug information. If the file already exists, it will be overridden. Default is False.
        build_all (boolean): a boolean that is true if you want to build all the sections of the PE file, false otherwise. Default is false.
    Returns:
        float: the mean absolute difference in bytes between the original samples and the adversarial samples.
    Raises:
        TypeError: if the gamma_attack parameter is not an object of one subclasses of GammaAttack.
    """
    if type(gamma_attack) == GammaAttack:
        raise TypeError("It is required an object of one subclasses of GammaAttack!")
    if not os.path.isfile(source_file) or not os.path.isdir(destination_folder):
        raise ValueError("source_file and destination_folder must be valid paths to file and folder respectively")
    if model is None or not isinstance(model, ModelWrapper):
        raise ValueError("Model must be a valid ModelWrapper object!")
    if result_file is not None:
        data_to_save = {}
    
    # read the pickled file
    with open(source_file, 'rb') as filename:
        files = pickle.load(filename)
    
    for i in tqdm(range(len(files))):   
        try:
            original_file_path = files[i]
            if not os.path.isfile(original_file_path):
                continue
            filename = original_file_path.split('/')[-1]
            if debug:
                print(f"Processing {original_file_path}...")
            if "PE" not in magic.from_file(original_file_path):
                print(f"Note that {original_file_path} is not a PE file! Skipping...", file=sys.stderr)
                continue
            with open(original_file_path, "rb") as file_handle:
                sample = file_handle.read()
            # Set the input sample
            gamma_attack.set_sample(sample)
            # Run the attack
            result = gamma_attack.run()
            # Get the adversarial sample
            adv_sample = result.get_adv_sample()

            # Save the adversarial sample
            exe_object = lief.PE.parse(adv_sample)
            builder = lief.PE.Builder(exe_object)
            builder.build()
            if build_all:
                builder.build_dos_stub(enable = True)
                builder.build_imports(enable = True)
                builder.build_overlay(enable = True)
                builder.build_relocations(enable = True)
                builder.build_resources(enable = True)
                builder.build_tls(enable = True)
            builder.write(os.path.join(destination_folder,filename))
        except Exception as e:
            print("Error while processing file {}: {}".format(filename, e), file=sys.stderr)
            continue
        if result_file is not None:
                data_to_save[filename] = {}
                data_to_save[filename]['elapsed_time']= result.get_elapsed_time()
                data_to_save[filename]['iterations']= result.get_iterations()
                data_to_save[filename]['queries']= result.get_queries()
                data_to_save[filename]['stagnation']= result.get_stagnation()
                data_to_save[filename]['final_classification'] = model.classify_sample(adv_sample)
                data_to_save[filename]['injected_bytes'] = os.path.getsize(os.path.join(destination_folder, filename)) - os.path.getsize(original_file_path)

                if data_to_save[filename]['injected_bytes'] < 0:
                    print("\nWARNING: injected bytes < 0 for {} :\t Original Size {} \t Adv Size: {}\n".format(filename, os.path.getsize(original_file_path), os.path.getsize(os.path.join(destination_folder, filename))))
        
    if result_file is not None:
        data_to_save['attack_data'] = json.loads(gamma_attack.get_attack_characteristic())
        with open(result_file, 'w') as outfile:
            json.dump(data_to_save, outfile)
    return


def compute_bytes_differences(source_folder, destination_folder):
    """
    Computes the mean absolute difference in bytes between files in two folders.
    The two folders must contain the files with the same name.

    Args:
        source_folder (str): the path of the source folder
        destination_folder (str): the path of the destination folder

    Returns:
        float: the mean absolute difference in bytes between files in the two folders
    """
    if not os.path.isdir(source_folder) or not os.path.isdir(destination_folder):
        raise ValueError("source_folder and destination_folder must be valid paths to folders!")
    differences = []
    for f in os.listdir(source_folder):
        differences.append(abs(os.path.getsize(os.path.join(source_folder, f)) - os.path.getsize(os.path.join(destination_folder, f))))
    return np.mean(differences)

def extract_api_call_from_folder(folder, how_many):
    """
    Extracts API calls from a folder containing PE files.
    Taken from: https://github.com/pralab/secml_malware/blob/master/secml_malware/attack/blackbox/c_gammapi_evasion.py

    Args:
        folder (str): The path to the folder containing the PE files.
        how_many (int): The number of API calls to extract.

    Returns:
        list: A list of tuples containing the API calls extracted from the PE files.
    """
    api_calls = []
    for filename in os.listdir(folder):
        path = os.path.join(folder, filename)
        if "PE" not in magic.from_file(path):
            continue
        lief_pe_file = lief.PE.parse(path)
        if lief_pe_file is None:
            print("ERROR parsing {}".format(path), file=sys.stderr)
            continue
        for lib in lief_pe_file.imports:
            for fun in lib.entries:
                api_calls.append((lib.name,fun.name))
    api_calls = list(set(api_calls)) # remove duplicates
    api_calls = random.sample(api_calls, how_many)
    return api_calls
        
        