"""
Classifying Sequences of Extreme Length with Constant Memory Applied to Malware Detection
Edward Raff, William Fleshman, Richard Zak, Hyrum Anderson and Bobby Filar and Mark Mclean
https://arxiv.org/abs/2012.09390

Taken from https://github.com/NeuromorphicComputationResearchProgram/MalConv2
"""
import torch
import torch.nn as nn
import torch.nn.functional as F

from ml_pentest.models.dl_models.raw_bytes_based.LowMemConv import LowMemConvBase


class MalConv(LowMemConvBase):
    
    def __init__(self, out_size=2, channels=128, window_size=512, stride=512, embd_size=8, log_stride=None, load_pretrained=True):
        super(MalConv, self).__init__()
        self.embd = nn.Embedding(257, embd_size, padding_idx=0)
        if not log_stride is None:
            stride = 2**log_stride
    
        self.conv_1 = nn.Conv1d(embd_size, channels, window_size, stride=stride, bias=True)
        self.conv_2 = nn.Conv1d(embd_size, channels, window_size, stride=stride, bias=True)
        
        self.fc_1 = nn.Linear(channels, channels)
        self.fc_2 = nn.Linear(channels, out_size)
        
        if load_pretrained:
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
            import os
            model_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'malconv2_pretrained.pt')

            self.load_state_dict(torch.load(model_path, map_location=device))
            print("Pretrained model loaded on device: ", device)   
        
    
    def processRange(self, x):
        x = self.embd(x)
        x = torch.transpose(x,-1,-2)
         
        cnn_value = self.conv_1(x)
        gating_weight = torch.sigmoid(self.conv_2(x))
        
        x = cnn_value * gating_weight
        
        return x
    
    def forward(self, x):
        post_conv = x = self.seq2fix(x)
        
        penult = x = F.relu(self.fc_1(x))
        x = self.fc_2(x)
        return torch.sigmoid(x)